#!/bin/bash
#	hooks/post-commit  2.204.885  2019-10-04T16:58:57.373038-05:00 (CDT)  https://github.com/BradleyA/git-TEST-commit-automation.git  uadmin  five-rpi3b.cptx86.com 2.203-1-ge894b82  
#	   hooks/post-commit   COMMIT_FILE_LIST is not always being removed so change logic 
#	hooks/post-commit  2.199.861  2019-10-02T12:50:46.635136-05:00 (CDT)  https://github.com/BradleyA/git-TEST-commit-automation.git  uadmin  five-rpi3b.cptx86.com 2.198-1-g8ee34f1  
#	   close #38   hooks/post-commit   remove test cases after running if all test cases PASS  testing complete 
###  hooks/post-commit - Create production standard TESTing using .git/hooks #26 
#  post-commit - (git hook) run test cases if found
#      Loop through committed files found in COMMIT_FILE_LIST
#        - Note: pre-commit (git hook) created ${REPOSITORY_DIR}/hooks/COMMIT_FILE_LIST
#          Check if COMMIT_FILE has a 'TEST' directory
#              Create list of test cases
#                  Links *.expected (test case output) to other test cases requiring the same test case output
#                      Loop through _TEST_CASE
#                          Run _TEST_CASE
###  Production standard 3.0 shellcheck
###  Production standard 5.1.160 Copyright
#    Copyright (c) 2019 Bradley Allen
#    MIT License is in the online DOCUMENTATION, DOCUMENTATION URL defined below.
###  Production standard 1.3.496 DEBUG variable
#    Order of precedence: environment variable, default code
if [[ "${DEBUG}" == ""  ]] ; then DEBUG="0" ; fi   # 0 = debug off, 1 = debug on, 'export DEBUG=1', 'unset DEBUG' to unset environment variable (bash)
if [[ "${DEBUG}" == "2" ]] ; then set -x    ; fi   # Print trace of simple commands before they are executed
if [[ "${DEBUG}" == "3" ]] ; then set -v    ; fi   # Print shell input lines as they are read
if [[ "${DEBUG}" == "4" ]] ; then set -e    ; fi   # Exit command has a non-zero exit status
#
BOLD=$(tput -Txterm bold)
NORMAL=$(tput -Txterm sgr0)
RED=$(tput    setaf 1)
GREEN=$(tput  setaf 2)
YELLOW=$(tput setaf 3)
CYAN=$(tput   setaf 6)
#    Date and time function ISO 8601
get_date_stamp() {
  DATE_STAMP=$(date +%Y-%m-%dT%H:%M:%S.%6N%:z)
  TEMP=$(date +%Z)
  DATE_STAMP="${DATE_STAMP} (${TEMP})"
}

#    Fully qualified domain name FQDN hostname
LOCALHOST=$(hostname -f)

#    Version
#    Assumptions for the next two lines of code:  The second line in this script includes the script path & name as the second item and
#    the script version as the third item separated with space(s).  The tool I use is called 'markit'. See example line below:
#       template/template.sh  3.517.783  2019-09-13T18:20:42.144356-05:00 (CDT)  https://github.com/BradleyA/user-files.git  uadmin  one-rpi3b.cptx86.com 3.516  
SCRIPT_NAME=$(head -2 "${0}" | awk '{printf $2}')
SCRIPT_VERSION=$(head -2 "${0}" | awk '{printf $3}')
if [[ "${SCRIPT_NAME}" == "" ]] ; then SCRIPT_NAME="${0}" ; fi
if [[ "${SCRIPT_VERSION}" == "" ]] ; then SCRIPT_VERSION="v?.?" ; fi

#    UID and GID
USER_ID=$(id -u)
GROUP_ID=$(id -g)

###  Production standard 2.3.512 log format (WHEN WHERE WHAT Version Line WHO UID:GID [TYPE] Message)
new_message() {  #  $1="${SCRIPT_NAME}"  $2="${LINENO}"  $3="DEBUG INFO ERROR WARN"  $4="message"
  get_date_stamp
  echo -e "${NORMAL}${DATE_STAMP} ${LOCALHOST} ${1}[$$] ${SCRIPT_VERSION} ${2} ${USER} ${USER_ID}:${GROUP_ID} ${BOLD}[${3}]${NORMAL}  ${4}"
}

if [[ "${DEBUG}" == "1" ]] ; then new_message "${SCRIPT_NAME}" "${LINENO}" "INFO" "  Started..." 1>&2 ; fi

###  Production standard 10.0 TESTing 

REPOSITORY_DIR=$(git rev-parse --show-toplevel)
if [[ ! -r "${REPOSITORY_DIR}/hooks/COMMIT_FILE_LIST" ]] ; then echo "COMMIT_FILE_LIST is created by pre-commit (git hook) and is required input for this script." ; exit 1 ; fi
COMMIT_FILE_LIST=$(cat "${REPOSITORY_DIR}"/hooks/COMMIT_FILE_LIST)

if [[ "${DEBUG}" == "1" ]] ; then new_message "${SCRIPT_NAME}" "${LINENO}" "DEBUG" "  Files being committed hy ${GIT_AUTHOR_NAME} (${USER}): >${COMMIT_FILE_LIST}<" 1>&2 ; fi
echo    "${BOLD}${YELLOW}"
echo    "'####:'##::: ##:::::::'########:'########::'######::'########:"
echo    ". ##:: ###:: ##:::::::... ##..:: ##.....::'##... ##:... ##..::"
echo    ": ##:: ####: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::"
echo    ": ##:: ## ## ##:::::::::: ##:::: ######:::. ######::::: ##::::"
echo    ": ##:: ##. ####:::::::::: ##:::: ##...:::::..... ##:::: ##::::"
echo    ": ##:: ##:. ###:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::"
echo    "'####: ##::. ##:::::::::: ##:::: ########:. ######::::: ##::::"
echo    "....::..::::..:::::::::::..:::::........:::......::::::..:::::${NORMAL}"

#    Loop through committed files found in COMMIT_FILE_LIST
#    - Note: pre-commit (git hook) created ${REPOSITORY_DIR}/hooks/COMMIT_FILE_LIST
for COMMIT_PATH_FILE_NAME in ${COMMIT_FILE_LIST} ; do
  COMMIT_FILE_NAME=$(echo "${COMMIT_PATH_FILE_NAME}" | rev | cut -d '/' -f 1 | rev)  # Did not use baseline becasue I did not want to eliminate directories with a dot trailing SUFFIX
  COMMIT_PATH="${COMMIT_PATH_FILE_NAME//${COMMIT_FILE_NAME}/}"
  if [[ "${DEBUG}" == "1" ]] ; then new_message "${SCRIPT_NAME}" "${LINENO}" "DEBUG" "  \${COMMIT_PATH_FILE_NAME} >${COMMIT_PATH_FILE_NAME}< \${COMMIT_FILE_NAME} >${COMMIT_FILE_NAME}< \${COMMIT_PATH} >${COMMIT_PATH}< \${COMMIT_PATH}TEST/\${COMMIT_FILE_NAME} >${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}<" 1>&2 ; fi
  #    Check if COMMIT_FILE has a 'TEST' directory
  if [[ -d "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}" ]] ; then
    new_message "${SCRIPT_NAME}" "${LINENO}" "${YELLOW}INFO" "  Test case directory found${NORMAL} (${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}) for ${GIT_AUTHOR_NAME} (${USER})." 1>&2
    cd "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}"

    ###  SA (Static Analysis)
    #    run SA-cleanup.sh if found
    if [[ -s "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/SA-cleanup.sh" ]] ; then
      "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/SA-cleanup.sh" "${REPOSITORY_DIR}"
    fi
    #    run SA-setup.sh if found
    if [[ -s "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/SA-setup.sh" ]] ; then
      "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/SA-setup.sh" "${REPOSITORY_DIR}"
    fi
    #    Create list of test cases
    SA_TEST_CASES=$(ls -1 | grep "^SA" | grep -v "\.")
    if [[ "${DEBUG}" == "1" ]] ; then new_message "${SCRIPT_NAME}" "${LINENO}" "DEBUG" " \${SA_TEST_CASES} >${SA_TEST_CASES}<" 1>&2 ; fi
    NO_TEST_CASES=$(ls -1 | grep "^SA" | grep -v "\." -c)
    NO_TEST_CASES_PASS=0
    NO_TEST_CASES_FAIL=0
    NO_TEST_CASES_ERROR=0
    TEST_CASES_ERROR_EXIT_CODE=""
    #    Loop through test cases
    for SA_TEST_CASE in ${SA_TEST_CASES} ; do
      #    Run SA_TEST_CASE(s)
      if [[ "${DEBUG}" == "1" ]] ; then new_message "${SCRIPT_NAME}" "${LINENO}" "DEBUG" "  \${REPOSITORY_DIR}/\${COMMIT_PATH}TEST/\${COMMIT_FILE_NAME}/\${SA_TEST_CASE} >${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/${SA_TEST_CASE}< \${REPOSITORY_DIR}/${COMMIT_PATH_FILE_NAME} >${REPOSITORY_DIR}/${COMMIT_PATH_FILE_NAME}<" 1>&2 ; fi
      TEST_CASE="${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/${SA_TEST_CASE} ${REPOSITORY_DIR}/${COMMIT_PATH_FILE_NAME}"
      eval "${TEST_CASE}"
      EXIT_CODE=${?}
      if [[ "${DEBUG}" == "1" ]] ; then new_message "${SCRIPT_NAME}" "${LINENO}" "DEBUG" "  \${EXIT_CODE} >${EXIT_CODE}<" 1>&2 ; fi
      if [[ ${EXIT_CODE} -eq 0 ]] ; then
        NO_TEST_CASES_PASS=$((NO_TEST_CASES_PASS+1))
      elif [[ ${EXIT_CODE} -eq 1 ]] ; then
        NO_TEST_CASES_FAIL=$((NO_TEST_CASES_FAIL+1))
      else
        NO_TEST_CASES_ERROR=$((NO_TEST_CASES_ERROR+1))
        TEST_CASES_ERROR_EXIT_CODE="${TEST_CASES_ERROR_EXIT_CODE}${EXIT_CODE} "
      fi
    done
    #    run SA-cleanup.sh if found
    if [[ -s "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/SA-cleanup.sh" ]] && [[ ${NO_TEST_CASES_FAIL} == 0 ]] && [[ ${NO_TEST_CASES_ERROR} == 0 ]] ; then
      "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/SA-cleanup.sh" "${REPOSITORY_DIR}"
    fi
    echo -e "\n     SA: ${BOLD}${YELLOW}${COMMIT_FILE_NAME}${NORMAL}\n   Number of test cases = ${BOLD}${NO_TEST_CASES}${NORMAL}\n   Number of test cases pass = ${BOLD}${GREEN}${NO_TEST_CASES_PASS}${NORMAL}\n   Number of test cases fail = ${BOLD}${RED}${NO_TEST_CASES_FAIL}${NORMAL}\n   Number of test cases error = ${BOLD}${CYAN}${NO_TEST_CASES_ERROR}${NORMAL}"
    echo  "${TEST_CASES_ERROR_EXIT_CODE}" | tr ' ' '\n' | grep '[^[:blank:]]' | sort | uniq -c | sort -k 2 -n  #  List error exit codes and how many of each exit code

    ###  FVT (Function Verification Test)
    #    run FVT-cleanup.sh if found
    if [[ -s "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/FVT-cleanup.sh" ]] ; then
      "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/FVT-cleanup.sh" "${REPOSITORY_DIR}"
    fi
    #    run FVT-setup.sh if found
    if [[ -s "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/FVT-setup.sh" ]] ; then
      "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/FVT-setup.sh" "${REPOSITORY_DIR}"
    fi
    #    Create list of FVT test cases
    FVT_TEST_CASES=$(ls -1 | grep "^FVT" | grep -v "\.")
    if [[ "${DEBUG}" == "1" ]] ; then new_message "${SCRIPT_NAME}" "${LINENO}" "DEBUG" "  \${FVT_TEST_CASES} >${FVT_TEST_CASES}<" 1>&2 ; fi
    NO_TEST_CASES=$(ls -1 | grep "^FVT" | grep -v "\." -c)
    NO_TEST_CASES_PASS=0
    NO_TEST_CASES_FAIL=0
    NO_TEST_CASES_ERROR=0
    TEST_CASES_ERROR_EXIT_CODE=""
    #    Loop through FVT_TEST_CASES
    for FVT_TEST_CASE in ${FVT_TEST_CASES} ; do
      #    Run FVT_TEST_CASE(s)
      if [[ "${DEBUG}" == "1" ]] ; then new_message "${SCRIPT_NAME}" "${LINENO}" "DEBUG" "  \${REPOSITORY_DIR}/${COMMIT_PATH_FILE_NAME} >${REPOSITORY_DIR}/${COMMIT_PATH_FILE_NAME}<" 1>&2 ; fi
      TEST_CASE="${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/${FVT_TEST_CASE} ${REPOSITORY_DIR}/${COMMIT_PATH_FILE_NAME}"
      eval "${TEST_CASE}"
      EXIT_CODE=${?}
      if [[ "${DEBUG}" == "1" ]] ; then new_message "${SCRIPT_NAME}" "${LINENO}" "DEBUG" "  \${EXIT_CODE} >${EXIT_CODE}<" 1>&2 ; fi
      if [[ ${EXIT_CODE} -eq 0 ]] ; then
        NO_TEST_CASES_PASS=$((NO_TEST_CASES_PASS+1))
      elif  [[ ${EXIT_CODE} -eq 1 ]] ; then
        NO_TEST_CASES_FAIL=$((NO_TEST_CASES_FAIL+1))
      else
        NO_TEST_CASES_ERROR=$((NO_TEST_CASES_ERROR+1))
        TEST_CASES_ERROR_EXIT_CODE="${TEST_CASES_ERROR_EXIT_CODE}${EXIT_CODE} "
      fi
    done
    #    run FVT-cleanup.sh if found
    if [[ -s "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/FVT-cleanup.sh" ]] && [[ ${NO_TEST_CASES_FAIL} == 0 ]] && [[ ${NO_TEST_CASES_ERROR} == 0 ]] ; then
      "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/FVT-cleanup.sh" "${REPOSITORY_DIR}"
    fi
    echo -e "\n     FVT: ${BOLD}${YELLOW}${COMMIT_FILE_NAME}${NORMAL}\n   Number of test cases = ${BOLD}${NO_TEST_CASES}${NORMAL}\n   Number of test cases pass = ${BOLD}${GREEN}${NO_TEST_CASES_PASS}${NORMAL}\n   Number of test cases fail = ${BOLD}${RED}${NO_TEST_CASES_FAIL}${NORMAL}\n   Number of test cases error = ${BOLD}${CYAN}${NO_TEST_CASES_ERROR}${NORMAL}"
    echo  "${TEST_CASES_ERROR_EXIT_CODE}" | tr ' ' '\n' | grep '[^[:blank:]]' | sort | uniq -c | sort -k 2 -n  #  List error exit codes and how many of each exit code
  else
    new_message "${SCRIPT_NAME}" "${LINENO}" "${YELLOW}INFO" "  No test case directory found${NORMAL} in ${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}, for ${GIT_AUTHOR_NAME}."
  fi
done
if [[ "${DEBUG}" == "0" ]] ; then  rm "${REPOSITORY_DIR}"/hooks/COMMIT_FILE_LIST ; fi #  Remove COMMIT_FILE_LIST if NOT in DEBUG

#    Process times
echo -e "\n     CPU Time    \n  user     sys"
times

###  Add code here to run additional post-commit hooks

#
if [[ "${DEBUG}" == "1" ]] ; then new_message "${SCRIPT_NAME}" "${LINENO}" "DEBUG" "  Operation finished." 1>&2 ; fi
###
